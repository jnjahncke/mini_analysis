#pragma rtGlobals=2		// Use modern global access method.//	Adapted From Bernardo Sabatini// 	Modifications//		1. 	Works under Igor Version 2.01//		2.	All frequencies specified in Hz, not kHz//		3.	Internally treats waves using double precision math, returns single precision result//		4.	All functions are compiled w/o use of "execute" commands.  This runs faster.//		5.	Multiplication by transfer function is coerced to use complex arithmetic.//			This avoids compile time assumption of real arithmetic.menu "Macros"	"Test Filter"	"Filter All On Graph"endfunction jf_LowPassFilter (InputWave, CutOffFreq, NumPoles)	wave		InputWave	variable	CutOffFreq					// 	Now in Hz, not kHz!	variable	NumPoles		duplicate 	/D/o InputWave temp_w		jf_PrepareWaveForFFT (temp_w)	jf_FilterInSitu (temp_w, 0, CutOffFreq, NumPoles)	duplicate /o temp_w $(nameofwave(InputWave)+"_F"+num2str(CutOffFreq))	killwaves temp_wend		function  jf_DeConvolve (ConvolveWave,OutputWave,CutOffFreq, NumPoles)	wave		OutputWave	wave 		ConvolveWave	variable	CutOffFreq					// 	Now in Hz, not kHz!	variable	NumPoles	duplicate 	/D/O OutputWave, temp_w1	duplicate 	/D/O ConvolveWave, temp_w2	Redimension/N=(numpnts(OutputWave))temp_w2	jf_PrepareWaveForFFT (temp_w1)	jf_PrepareWaveForFFT (temp_w2)	fft temp_w1		fft temp_w2	duplicate /D/O/C temp_w1  temp_cmplx				//  kluge to force multiplication to use complex algebra	duplicate /O/C/D temp_cmplx temp_fil					// create wave for filter transfer function	jf_BuildFilterTransferFunction (temp_fil, 0, CutOffFreq, NumPoles)	temp_cmplx = temp_w1/temp_w2*temp_fil	ifft temp_cmplx										// take inverse FFT to return to time domain	duplicate /s/o temp_cmplx $("D_"+nameofwave(ConvolveWave)+"_"+nameofwave(OutputWave))end		function jf_FastFilter (InputWave, HighCutOffFreq, NumPoles)	wave		InputWave	variable	HighCutOffFreq		// Now in Hz, not kHz!	variable	NumPoles		jf_FastBPFilter (InputWave, 0, HighCutOffFreq, NumPoles)endfunction jf_FastBPFilter (InputWave, LowCutOffFreq, HighCutOffFreq, NumPoles)	wave		InputWave	variable	LowCutOffFreq, HighCutOffFreq		// Now in Hz, not kHz!	variable	NumPoles	variable	oldpnts		if ((lowcutofffreq == 0) && (highcutofffreq == 0))	// i.e. don't want to filter		return 0	endif	oldpnts = numpnts (inputwave)	jf_PrepareWaveForFFT (InputWave)	jf_FilterInSitu (InputWave, LowCutOffFreq, HighCutOffFreq, NumPoles)	redimension /s/n=(oldpnts) InputWaveend		function jf_FilterInSitu	(InputWave,LowCutOffFreq, HighCutOffFreq, NumPoles)	wave		InputWave	variable 	LowCutOffFreq, HighCutOffFreq	variable	NumPoles	variable	oldx		oldx = leftx (inputwave)	duplicate	/O/D	InputWave, temp_double	fft	temp_double										// take FFT to convert to freq. domain	duplicate /O/C/D temp_double temp_fil					// create wave for filter transfer function	jf_BuildFilterTransferFunction (temp_fil, LowCutOffFreq, HighCutOffFreq, NumPoles)	duplicate	/D/o/c temp_double  temp_cmplx			//	KLUGE to force multiplication to use complex algebra	temp_cmplx *= temp_fil	ifft temp_cmplx										// take inverse FFT to return to time domain	duplicate	/S/O	temp_cmplx, InputWave	KillWaves	temp_double, temp_cmplx, temp_fil	SetScale/P x oldx,deltax(inputwave), inputwaveend		function	jf_PrepareWaveForFFT (W)	wave	/D	W	jf_AdjustNumberofPoints (W)			//	Adjusts wave dimensioning to 2^n points for FFT	jf_ConvertNaNs(W)					// 	Converts all NaNs to zerosendfunction	jf_AdjustNumberofPoints (W)	wave		/D	w	variable	num_bits, num_points	variable	/D	factor		factor = 1/(log(2))	num_bits = factor * log (numpnts (W))	num_points = 2 ^ (ceil (num_bits))	redimension /D/n=(num_points) WendFunction jf_ConvertNaNs(theWave)	Wave		/D		theWave 	Variable 	p, numPoints	Variable	 val	// numNaNs = 0	wavestats /q thewave	if (V_numNans != 0)		p = 0											// the loop index		numPoints = numpnts(theWave)				// number of times to loop		do			val = theWave[p]			if (numtype(val)==2)						// is this NaN?				theWave[p] = 0			endif			p += 1		while (p < numPoints)	endifEndfunction jf_BuildFilterTransferFunction (W, LowCutOffFreq, HighCutOffFreq,NumPoles)	wave /D/c		W	variable	LowCutOffFreq, HighCutOffFreq				// in Hz	variable	NumPoles	redimension /D/r W				// throw away imag. part of complex wave	wave	wr = W		if ((LowCutOffFreq == 0) && (HighCutOffFreq > 0))		wr = 1/(1+(x/(HighCutOffFreq))^NumPoles)		return 0	endif	if ((LowCutOffFreq > 0) && (HighCutOffFreq == 0))		wr = 1 - 1/(1+(x/(LowCutoffFreq))^NumPoles)		return 0	endif	if ((LowCutOffFreq > 0) && (HighCutOffFreq > 0) && (HighCutOffFreq > LowCutOffFreq))		wr = 1/(1+(x/(HighCutOffFreq))^NumPoles) * (1 - 1/(1+(x/(LowCutoffFreq))^NumPoles))		return 0	endif	wr = 1endfunction jf_FasterBPFilter (w, LowCutOffFreq, HighCutoffFreq, NumPoles)	wave		w	variable	LowCutOffFreq, HighCutOffFreq		// Now in Hz, not kHz!	variable	NumPoles	variable	oldpnts, oldx, hasNANs, i, startpos, thisslope, thisoffset		if ((lowcutofffreq == 0) && (highcutofffreq == 0))	// i.e. don't want to filter		return 0	endif		oldpnts = numpnts (w)				// preserve original leftx and numpnts (messed up by FFT)	oldx = leftx (w)	duplicate /o w W_NANs	w_nans = numtype(w_nans)	hasNANs = sum (w_nans, -inf, inf)	if (hasNANs > 0)		startpos = -1		for (i = 0; i < oldpnts; i += 1)			if ((w_nans[i] == 2) && (startpos == -1))	// starting NaN				startpos = i - 1			elseif ((w_nans[i] != 2) && (startpos > 0))	// ending NaN				thisslope = (w[i] - w[startpos]) / (i - startpos)				thisoffset = w[startpos] - thisslope * startpos				w[startpos + 1, i - 1] = p * thisslope + thisoffset				startpos = -1			endif		endfor	endif	redimension /D/n=(2 ^ (ceil (log (oldpnts)/log(2)))) w	// i.e. adjust # of points to power of 2	fft w	// do we need to recreate filter function?	if (!exists ("root:jf_filterSpecs"))		make /n=4 root:jf_filterSpecs=nan	endif	wave jf_filterSpecs=root:jf_filterSpecs	if ((lowcutofffreq != jf_filterspecs[0]) || (highcutofffreq != jf_filterspecs[1]) || (numpoles != jf_filterspecs[2]) || (numpnts (w) != jf_filterspecs[3]))		jf_filterspecs = {lowcutofffreq, highcutofffreq, numpoles, numpnts (w)}		duplicate /o/c/d w root:jf_filterFunc		jf_BuildFilterTransferFunction (root:jf_filterFunc, LowCutOffFreq, HighCutOffFreq, NumPoles)	endif	execute GetWavesDataFolder(w, 2) +" *= root:jf_filterFunc"	//	KLUGE to force multiplication to use complex algebra		// put back in time domain and clean up scaling, etc.	ifft w	redimension /s/n=(oldpnts) w	SetScale/P x oldx,deltax(w), w	if (hasNANs)		// w = selectnumber (w_nans[p]==2, w[p], nan)		for (i = 0; i < oldpnts; i += 1)			if (w_nans[i] == 2)				w[i]=nan			endif		endfor	endifend		Window TestFilter() : Graph	string oldfolder = GetDataFolder(1)	setdatafolder root:	make /o/n=0 jf_testFilter, jf_testFilterOriginal	variable /g jf_lowFreq, jf_highFreq, jf_numPoles=4	string /g jf_srcName, jf_destName	PauseUpdate; Silent 1		// building window...	Display /W=(330,139,710,403)/k=1 jf_testFilterOriginal,jf_testFilter as "Test Filter"	modifygraph rgb(jf_testFilterOriginal)=(65535,49151,49151)	ControlBar 42	SetVariable setvar0,pos={1,22},size={82,15},proc=testFilterProc,title="Filter"	SetVariable setvar0,limits={0,Inf,100},value= jf_lowFreq	SetVariable setvar0_1,pos={152,22},size={60,15},proc=testFilterProc,title="Poles"	SetVariable setvar0_1,limits={1,Inf,1},value= jf_numPoles	SetVariable setvar0_2,pos={88,22},size={60,15},proc=testFilterProc,title="-"	SetVariable setvar0_2,limits={0,Inf,100},value= jf_highFreq	SetVariable setvar1,pos={2,4},size={88,15},proc=testFilterProc,title="Source"	SetVariable setvar1,limits={-Inf,Inf,1},value= jf_srcName	SetVariable setvar1_1,pos={99,4},size={88,15},title="Dest"	SetVariable setvar1_1,limits={-Inf,Inf,1},value= jf_destName	Button button0,pos={197,1},size={50,20},proc=ApplyFilterButtonProc,title="Apply"	SetDrawLayer UserFront	setdatafolder oldfolderEndMacroFunction testFilterProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	SVAR jf_srcName=root:jf_srcName	NVAR jf_lowfreq=root:jf_lowfreq, jf_highfreq=root:jf_highfreq, jf_numpoles=root:jf_numpoles	if (strlen (jf_srcName) != 0)		duplicate /o $jf_srcName root:jf_testFilterOriginal, root:jf_testFilter		jf_FasterBPFilter (root:jf_testFilter, jf_lowfreq, jf_highfreq, jf_numpoles)	else		make /n=0/o root:jf_testFilterOriginal, root:jf_testFilter	endifEndFunction ApplyFilterButtonProc(ctrlName) : ButtonControl	String ctrlName		SVAR jf_srcName=root:jf_srcName, jf_destName=root:jf_destName	NVAR jf_lowfreq=root:jf_lowfreq, jf_highfreq=root:jf_highfreq, jf_numpoles=root:jf_numpoles	if (strlen (jf_destname) == 0)		abort "No destination wave given."	endif	if (cmpstr (jf_srcName, jf_destName) != 0)	// i.e. not the same		duplicate /o $jf_srcName $jf_destName	endif	jf_FasterBPFilter ($jf_destName, jf_lowfreq, jf_highfreq, jf_numpoles)Endfunction FilterAllOnGraph ()	variable i	if (!exists ("root:jf_lowfreq"))		abort "Use \"Test Filter\" to set up filter characteristics."	endif	doalert 1, "Warning: This function is not undoable.  Proceed?"	if (v_flag != 1)		return 0	endif	getwindow kwTopWin, wavelist	wave /t w_wavelist	NVAR jf_lowfreq=root:jf_lowfreq, jf_highfreq=root:jf_highfreq, jf_numpoles=root:jf_numpoles	for (i = 0; i < dimsize (w_wavelist, 0); i += 1)		jf_FasterBPFilter ($(w_wavelist[i][1]), jf_lowfreq, jf_highfreq, jf_numpoles)	endforend